"""Offline uplift evaluation utilities for A/B experiments."""

from __future__ import annotations

import math
from dataclasses import dataclass
from typing import Dict, List, Optional

import pandas as pd


def _is_valid(value: Optional[float]) -> bool:
    return value is not None and not pd.isna(value)


def _normal_cdf(z: float) -> float:
    return 0.5 * (1.0 + math.erf(z / math.sqrt(2.0)))


def _two_sided_pvalue_from_z(z: float) -> float:
    return max(0.0, min(1.0, 2.0 * (1.0 - _normal_cdf(abs(z)))))


def _two_proportion_z_test(
    control_success: float,
    control_total: float,
    test_success: float,
    test_total: float,
) -> Optional[float]:
    if control_total <= 0 or test_total <= 0:
        return None
    p_pool = (control_success + test_success) / (control_total + test_total)
    variance = p_pool * (1.0 - p_pool) * (1.0 / control_total + 1.0 / test_total)
    if variance <= 0:
        return 1.0
    diff = (test_success / test_total) - (control_success / control_total)
    z = diff / math.sqrt(variance)
    return _two_sided_pvalue_from_z(z)


def _ratio_mean_p_value(
    control_sum: float,
    control_sum_squares: float,
    control_count: float,
    test_sum: float,
    test_sum_squares: float,
    test_count: float,
) -> Optional[float]:
    if control_count <= 1 or test_count <= 1:
        return None
    control_mean = control_sum / control_count
    test_mean = test_sum / test_count
    control_var = max(control_sum_squares / control_count - control_mean**2, 0.0)
    test_var = max(test_sum_squares / test_count - test_mean**2, 0.0)
    se = math.sqrt(control_var / control_count + test_var / test_count)
    if se == 0:
        return 1.0
    z = (test_mean - control_mean) / se
    return _two_sided_pvalue_from_z(z)


@dataclass
class UpliftReport:
    """Container for uplift evaluation results."""

    control_variant: str
    table: pd.DataFrame

    def to_dataframe(self) -> pd.DataFrame:
        """Return a copy of the underlying dataframe."""

        return self.table.copy()

    def to_markdown(self) -> str:
        """Render the table as GitHub-flavoured markdown."""

        try:
            return self.table.to_markdown(index=False)
        except ImportError:
            return self.table.to_string(index=False)


class UpliftEvaluator:
    """Compute metric lifts and significance from aggregated offline data."""

    def __init__(self, *, control_variant: str, variant_column: str = "variant") -> None:
        self.control_variant = control_variant
        self.variant_column = variant_column

    def evaluate(self, data: pd.DataFrame) -> UpliftReport:
        table = evaluate_uplift(
            data,
            control_variant=self.control_variant,
            variant_column=self.variant_column,
        )
        return table


def evaluate_uplift(
    data: pd.DataFrame,
    *,
    control_variant: str,
    variant_column: str = "variant",
) -> UpliftReport:
    """Compute CTR/CR/GMV/ROAS lifts and statistical significance.

    The ``data`` argument is expected to contain aggregated metrics with at
    least the following columns per variant:

    ``impressions``
        Number of impressions (or traffic units) analysed.
    ``clicks``
        Number of clicks generated by the impressions.
    ``conversions``
        Number of conversions/orders.
    ``gmv``
        Gross merchandise value generated by the traffic (sum over all
        impressions).
    ``spend``
        Advertising spend associated with the traffic.  ``ROAS`` is calculated as
        ``gmv / spend``.

    Optionally the dataframe may contain ``gmv_sq`` and ``roas_sq`` which denote
    the sum of squares of the per-impression GMV and ROAS values.  When provided
    alongside ``roas`` (sum of per-impression ROAS values) the evaluator will
    compute p-values for the corresponding metrics using a normal approximation.
    """

    if variant_column not in data.columns:
        raise ValueError(f"'{variant_column}' column is required for uplift evaluation")

    aggregation: Dict[str, str] = {}
    for column in [
        "impressions",
        "clicks",
        "conversions",
        "gmv",
        "gmv_sq",
        "spend",
        "roas",
        "roas_sq",
    ]:
        if column in data.columns:
            aggregation[column] = "sum"

    if "impressions" not in aggregation:
        raise ValueError("'impressions' column is required for uplift evaluation")

    summary = data.groupby(variant_column).agg(aggregation).reset_index()

    if control_variant not in summary[variant_column].values:
        raise ValueError(f"Control variant '{control_variant}' not found in data")

    summary = summary.set_index(variant_column)
    control_row = summary.loc[control_variant]

    metrics: List[Dict[str, Optional[float]]] = []
    for variant, row in summary.iterrows():
        impressions = row.get("impressions", 0.0)
        clicks = row.get("clicks", 0.0)
        conversions = row.get("conversions", 0.0)
        gmv = row.get("gmv", 0.0)
        gmv_sq = row.get("gmv_sq") if "gmv_sq" in row.index else None
        spend = row.get("spend", 0.0)
        roas_sum = row.get("roas") if "roas" in row.index else None
        roas_sq = row.get("roas_sq") if "roas_sq" in row.index else None

        ctr = clicks / impressions if impressions else 0.0
        cr = conversions / clicks if clicks else 0.0
        gmv_per_impression = gmv / impressions if impressions else 0.0
        if roas_sum is not None:
            roas = roas_sum / impressions if impressions else 0.0
        else:
            roas = gmv / spend if spend else 0.0

        metrics.append(
            {
                "variant": variant,
                "ctr": ctr,
                "cr": cr,
                "gmv_per_impression": gmv_per_impression,
                "roas": roas,
                "impressions": impressions,
                "clicks": clicks,
                "conversions": conversions,
                "gmv": gmv,
                "gmv_sq": gmv_sq,
                "spend": spend,
                "roas_sum": roas_sum,
                "roas_sq": roas_sq,
            }
        )

    metric_frame = pd.DataFrame(metrics)
    control_metrics = metric_frame.loc[metric_frame["variant"] == control_variant].iloc[0]

    records: List[Dict[str, Optional[float]]] = []
    for _, row in metric_frame.iterrows():
        variant = row["variant"]
        lift_ctr = _compute_lift(row["ctr"], control_metrics["ctr"])
        lift_cr = _compute_lift(row["cr"], control_metrics["cr"])
        lift_gmv = _compute_lift(row["gmv_per_impression"], control_metrics["gmv_per_impression"])
        lift_roas = _compute_lift(row["roas"], control_metrics["roas"])

        p_ctr = _two_proportion_z_test(
            control_metrics["clicks"],
            control_metrics["impressions"],
            row["clicks"],
            row["impressions"],
        )
        p_cr = _two_proportion_z_test(
            control_metrics["conversions"],
            control_metrics["clicks"],
            row["conversions"],
            row["clicks"],
        )

        p_gmv = None
        if _is_valid(row.get("gmv_sq")) and _is_valid(control_metrics.get("gmv_sq")):
            p_gmv = _ratio_mean_p_value(
                control_row.get("gmv", 0.0),
                control_row.get("gmv_sq", 0.0),
                control_row.get("impressions", 0.0),
                row["gmv"],
                row.get("gmv_sq", 0.0),
                row["impressions"],
            )

        p_roas = None
        control_roas_sum = control_metrics.get("roas_sum")
        if (
            _is_valid(row.get("roas_sq"))
            and _is_valid(row.get("roas_sum"))
            and _is_valid(control_metrics.get("roas_sq"))
            and _is_valid(control_roas_sum)
        ):
            p_roas = _ratio_mean_p_value(
                float(control_roas_sum),
                control_metrics.get("roas_sq", 0.0),
                control_metrics.get("impressions", 0.0),
                row.get("roas_sum", 0.0),
                row.get("roas_sq", 0.0),
                row["impressions"],
            )

        for metric_name, value, lift, p_val in [
            ("CTR", row["ctr"], lift_ctr, p_ctr),
            ("CR", row["cr"], lift_cr, p_cr),
            ("GMV per impression", row["gmv_per_impression"], lift_gmv, p_gmv),
            ("ROAS", row["roas"], lift_roas, p_roas),
        ]:
            records.append(
                {
                    "variant": variant,
                    "metric": metric_name,
                    "value": value,
                    "lift_vs_control": lift,
                    "p_value": p_val,
                }
            )

    report_df = pd.DataFrame(records)
    return UpliftReport(control_variant=control_variant, table=report_df)


def _compute_lift(test_value: float, control_value: float) -> Optional[float]:
    if control_value == 0:
        return None if test_value else 0.0
    return (test_value - control_value) / control_value
